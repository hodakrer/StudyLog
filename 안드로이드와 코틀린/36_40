[36. 지역변수와 전역변수]

  지역변수란?
  -> 함수나 특정 스코프 내에서 선언된 변수.

  지역변수의 특징은?
  -> 함수나 특정 스코프 밖을 빠져나가면 사라진다.

  함수의 매개변수는 지역변수인가?
  -> Yes. 함수가 끝나면 매개변수도 사라진다.

  전역변수란?
  -> 함수 밖에서 선언된 변수.
  -> 어떤 함수를 빠져나가도 그대로 유지되며, 어떤 함수 안에서도 사용할 수 있다.

  스코프란?
  -> 어떤 변수가 인식될 수 있는 범위.


[37. 지역변수와 전역변수 이름 중복]

  전역변수와 지역변수의 이름이 같으면?
  -> 지역변수가 선언된 스코프에선 (그 코드 아래부터 함수가 끝날 때까지) 지역변수를 우선한다.


[38. 함수 A의 지역변수와 함수 B의 지역변수 명이 같다면?]

  둘이 같다면?
  -> 어차피 스코프가 다르기 때문에 이름이 같아도 된다.


[39. 지역함수]

  지역함수란?
  -> 특정 블록(함수) 안에 선언된 함수.

  예를 들어?
  -> fun main(args: Array<String> ){
    fun calculate(num1 : Int, num2 : Int) {
      print(num1 + num2)
    }
  }

  왜 지역함수를 쓰나?
  -> 스코프 안에 스코프. 즉 상위 스코프의 지역변수를 사용할 수 있다.
  -> 굳이 인자(Arguments)로 넘길 필요가 없다!

  그럼 인자로 넘기면 되는데 왜?
  -> 가독성이 좋다! (코드 줄 줄일 수 있다)

  이런 개념을 뭐라고 하나?
  -> 클로저

  클로저의 정의란?
  -> 자신이 선언될 때 외부 변수를 기억하는 함수

  또 예시 코드?
  -> fun makeMultiplier(x: Int): (Int) -> Int {
    return { y -> x * y } // 이 람다가 클로저! x를 기억함
  }
  -> 이렇다면 return {} 스코프 속 선언된 y -> x * y가 외부에서 온 변수인 x: Int를 마음대로 사용할 수 있다!


[40. 메모리의 스택 영역]

  변수 선언 시 실제로 저장되는 영역?
  -> 메모리 속 스택 영역.

  변수 저장 시 어떤 자료구조적 형태로 저장되나?
  -> FILO식인 스택 형태로 쌓아올려진다.

  main 함수 실행 시 가장 먼저 스택에 깔리는 변수는?
  -> args

  fun main (args: Array<String> ) {
    val a = 30
    val result = plusOne(a)
  }

  fun plusOne (a : Int) return a + 1
  이라면, 스택영역에 쌓이는 순서는?
  -> args
  -> args, a(30)
  -> args, a(30), (실제 물리메모리에 1이 올라가진 않는다. 그러나 jvm operand stack엔 계산을 위해 1이 올라간다.)
  -> (jvm 명령어인 iadd 실행. jvm operand stack에서 물리 스택 메모리 속 a값 부름. 그리고 상수 1을 스택에 부름)
  -> args, result(a + 1)
  -> (main 함수 종료)
  
