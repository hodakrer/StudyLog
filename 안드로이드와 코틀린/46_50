[46 & 48. 메모리의 힙 영역과 그 존재 이유]

  스택 영역은 뭘 저장하나?
  -> 코드에서 생성한 변수 (컴파일 시 크기가 결정되는 것들)

  힙 영역은 뭘 저장하나?
  -> 객체(저번 시간에 공부한 object라던가), 참조변수의 참조값(그래서 리스트를 인자로 넣으면 그 큰 값이 딥카피되지 않고 참조값만 넘어간다).

  예를 들어 Array를 반환하면 메모리 속 힙 영역에서 일어나는 일은?
  -> 그 큰 Array가 딥카피되어 반환되는 게 아니다.
  -> 참조값만 반환된다. 함수 반환값을 받은 매개변수는 그 참조값을 받는다.
  -> 즉, 스택 영역의 변수는 스코프를 벗어나면 사라진다.
  -> 그러나 힙 영역의 변수는 스코프를 벗어나도 안 사라진다.
  (마치 라이프사이클을 따르는 UI변수들과 라이프사이클에 초탈한 레포지토리 객체를 보는 것 같다)

  힙 영역의 변수는 언제 사라지나?
  (무슨 메모리누수처럼 들린다)
  -> 자신을 참조하는 변수가 없으면 GC가 그 상태를 인지하고 삭제한다.
  

[47. 클래스]

  클래스 선언해보시오.
  -> class Person {
    val nationality: String = "Korea"
    var name: String = "Alice"
  }

  왜 클래스가 생겼나 (무엇에서 발전했나)?
  -> 같은 객체를 매번 object {}로 반복 생성했기 때문.

  그래서 클래스를 표현하자면?
  -> 붕어빵틀.

  그럼 생성된 인스턴스는?
  -> 붕어빵 그 자체.

  코틀린은 클래스 이름과 파일 이름이 같아야 하나?
  -> 아뇽.

  코틀린은 파일 하나 당 클래스 하나만 존재할 수 있나?
  -> 아뇽. 그래서,
      // 새 메시지 응답을 위한 데이터 클래스
      data class ChatMessageCreateResponse(
          val status: Int,
          val message: String,
          val data: ChatMessageCreateData?
      )
      
      // 응답 내 실제 메시지 데이터
      data class ChatMessageCreateData(
          val chatRoomId: String,
          val messageId: Int,
          val senderEmail: String,
          val messageTime: String,
          val messageText: String?,
          val imageUrl: String?,
          val isImage: Boolean
      )  처럼 한 .kt파일에 두 클래스를 생성할 수 있다.


  코틀린의 클래스는 기본 접근지정자가 무엇인가?
  -> public

  근데 왜 평소에 써본 기억이 없지?
  -> 아무것도 안쓰면 컴파일러에서 기본 public이라 인식.

  근데 정보은닉을 고려하면 private이 아닌 이유가 뭘까?
  -> 자바를 보니 많은 클래스/메서드가 public이라.
  -> Boilerplate 감소시키려는 코틀린의 철학이 담긴 것!


[49. 문자열간 + 연산 시 주의점 = Concatenate시 주의점]

  참조타입인 건?
  -> 기본타입 뺀 모든 타입들. 참조타입엔 스트링도 포함된다.

  참조타입끼리 + 하면 힙 영역에서 일어나는 일?
  -> 두 값을 Concatenate한 새로운 값이 힙 영역에 쌓인다.
  -> 또한 덮어씌워진 변수가 원래 가리키던 오리지널 참조값은 누구도 참조하지 않지만 힙 영역 자리를 차지한다.
  (이런 걸 GC가 지워준다는 거 아닌가?)

  GC가 있는데 왜 걱정하지?
  -> GC 돌리는 비용! (CPU 추가 업무. 그 동안 프로그램 멈춰서 프레임 하락)

  해결법?
  -> StringBuilder() 쓰자.
  -> 하나의 StringBuffer객체를 재사용해서 GC 안 돌려도 됨.


[50. GC]

  아까 말한 참조되지 않는 힙 영역의 객체는 뭐라 부르나?
  -> 미아 객체.

  GC의 역할?
  -> 힙 영역 속 미아 객체를 수거하는 역할.

  GC의 주의점?
  -> GC 도는 동안 프로그램 멈추는 프리징. -> 성능저하.
