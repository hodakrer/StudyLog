[41. 소스 파일 여러 개로 분리]

  소스 파일 쪼개는 이유?
  -> 프로그램 커지면 한 파일에 모든 코드 넣기 어렵다.

  소스 파일을 쪼갤 수 있는 단위?
  -> 함수

  그런데 파일 별로 분리된 함수를 어떻게 불러오나?
  -> 같은 패키지로 담아두면 불러올 수 있다.


[42. 패키지]

  패키지란?
  -> 코틀린 소스 파일을 담은 폴더

  패키지 이름에 대한 규칙?
  -> 소문자로(스네이크).

  소문자로 적는 걸 추천하는 이유?
  -> 클래스와 편하게 구분하기 위함.
  -> 클래스는 대문자로 시작한다(파스칼).

  직접 써보자!
  -> package plustalk1
     fun calculate(num1 : Int, num2 : Int) : Int = num1 + num2

     _________________
     package plustalk1
     fun main(args : Array<String> ) : Unit = println(calculate(1, 2) )

  패키지 키워드가 알리는 것?
  -> 이 소스 파일이 어느 패키지에 포함되어 있는지 알림.

  패키지 선언문과 실제 폴더 구조가 일치하지 않으면?
  -> 패키지 선언문 중심으로 JVM이 동작한다.

  그러면 일치하지 않고 적어도 되나?
  -> 팀 프로젝트에서 혼동을 주기 때문에 '지양'해야함.


[43. 다른 패키지에 있는 함수를 호출하려면?]

  다른 패키지 속 함수를 사용하고 싶다면?
  -> 바로 다른_패키지_이름.함수_이름( ) 라 쓰면 된다.



[44. import]

  패키지 이름 쓰면 되는데 import는 왜 쓰나?
  -> 매번 패키지 이름 쓰는 건 Boilerplate Code니까!

  import 쓰는 법?
  -> import 패키지_이름.함수_이름
  -> import 패키지_이름.함수_이름 as 별명
  (마치 파이썬의 import deque as dq와 같다)


[45. 객체 (object) ]

  객체의 정의란?
  -> 연관 있는 변수를 묶어둔 덩어리.

  객체 속에서 정의한 변수는 따로 뭐라 부르나?
  -> 프로퍼티 (속성)

  프로퍼티는 그냥 변수와 뭐가 다르나?
  -> 변수 + 게터/세터 (이것 또한 Boilerplate code를 줄여주는 코틀린의 장점!)

  써보자.
  -> val student = object {
     val name : String = "Alice"
     val age  : Int    = 36
     }

  이거와 object 클래스는 무슨 차이인가?
  -> 여기의 object    : 익명 객체.
  -> object class 선언: 싱글턴 클래스 선언 (동시에 동명의 객체도 만들어진다!)

  

  

  
