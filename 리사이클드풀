서론:

  어제 리사이클러뷰를 설명하며 나온 리사이클드풀이다.
  이건 recyclerview.recycler 객체 속에 구현된 inner class다.


getRecycledView():
  이 함수를 통해 뷰타입마다 각 뷰홀더풀울 가진다는 걸 알 수 있다.

  인풋: 뷰타입 정보
  아웃풋: 뷰타입에 맞는 뷰홀더

본론:

  리사이클드뷰풀은 리사이클러뷰 최적화를 위한 것이다.
  구체적으론 같은 타입의 뷰홀더면 여러 리사이클러뷰가 동일한 뷰타입을 공유할 수 있게 해준다!
  그 근거는? 리사이클드뷰풀의 함수를 보라. 놀랍게도 public이다!

Default.max_SCRAP:

  뷰타입 별로 뷰홀더풀은 기본 5개를 준비해놓는다.
  이걸 늘리려면 setMaxRecycledViews()를 사용하자.
  인풋: 뷰타입 & 뷰홀더 개수
  아웃풋: 뷰홀더 풀의 용량을 늘이고 줄일 수 있다!

  그런데 무슨 기준으로 써먹어야하는가?

  1. 뷰타입이 많은 경우 -> 풀의 개수를 늘리면 빨라진다.
  2. 뷰타입이 적은 경우 -> 풀의 개수를 줄여 메모리를 절약한다.


더티뷰:

  상태(position, flag)등이 제거된 채 뷰, 뷰타입만 남은 걸 더티뷰라 한다.
  이걸 쓰려면 다시 데이터바인딩을 해줘야한다.

  그러나 캐시 속 뷰는 상태(position, flag)가 남아있어 데이터바인딩을 생략하고 바로 쓸 수 있다!


캐시 <-> 리사이클드뷰풀:

  뷰홀더를 찾을 때 아래의 과정을 거친다.

  1. 캐시에 있나 확인.
  2. 없으면 리사이클드뷰 확인.
  3. 그래도 없으면 createViewHolder()로 뷰홀더 생성!

  그럼 데이터들도 다음과 같은 과정을 거친다.
  1. 캐시 (위치, 상태 알고있다)-> 바인딩없이 바로 layout manager에게 보내짐.
  2. 뷰타입 (위치, 상태 모른다)-> 뷰바인딩 선행하고 layout mamager로 보내짐.
  3. 뷰홀더 생성 (이하 동문)



후기:

  오늘은 자기소개서 쓰느라 바빠서 많이 공부하진 못했다.
  하지만 빼먹지 않은게 어디랴.








