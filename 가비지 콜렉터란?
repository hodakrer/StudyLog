배경:

  하루에 자소서 쓰느라 밤 11시에 끝났다. 하지만 스킵할 수는 없는 노릇.
  그래도 최소한만 공부하고 자자.


가비지 컬렉터 (GC):

  코틀린은 자바(JVM)의 가비지 컬렉터를 사용한다.
  가비지 컬렉터는 '객체 관리'를 한다.
  객체 관리란 객체 생성, 유지, 그리고 메모리에서해제하는 과정이다.
  즉, 객체 관리에서 객체를 해제할 때 가비지 컬렉터를 쓴다.


왜 존재해야하는가?:

  10년전 C 언어 수업에서 malloc과 free를 기억하라.
  객체를 무한정 메모리에 올려둘 수 없는 노릇.
  낄끼빠빠의 정신으로 쓸모 없는 객체를 삭제해야 새 객체를 위한 자리가 생긴다.
  시뮬레이션 게임을 좋아하는 사람으로서, 데이터가 캐시에 꽉 차서 고통 받은 기억은 수도 없이 많다!


그럼 무슨 기준으로 객체를 해제하나?

  1. 참조 카운트 방식. 참조되는 횟수가 0이 되면 해제한다.
  단점: 순환 참조하면 계속 참조하니 횟수가 0이 되지 않는다!

  2. 루트 탐색 방식. 프로그램이 직접 접근할 수 있는 객체는 루트라 한다.
     그렇지 못한 객체는 해제한다.
  단점: 이 방식으로 가비지 컬렉터가 실행되면 잠시 프로그램이 멈춘다. -> 성능 저하 이슈.

메모리 누수란?

  사용 끝난 객체가 메모리에 계속 남아 자리를 차지하는 경우.

반대로 빠른 free란?

  너무 빨리 free해서 참조중인 코드가 찾으면 참조 오류가 난다.

아하! 그래서 Context에서 activity context를 activity 밖에서 쓰면 activity 생명주기에서 벗어나 메모리 누수가 나는구나!
(정확히는 내일 관련 글을 더 봐야겠다)

마지막으로 그래도 공식문서 한번 읽어주자.

---------------------------------------------------------------------
https://kotlinlang.org/docs/native-memory-manager.html

가비지 콜렉터


가비지 콜렉터 수동으로 시작하기


가비지 콜렉터 성능 체크법


가비지 콜렉터 최적화법



가비지 콜렉터 끄기



메모리 누출로-> 메모리 릭 모니터링



메모리 릭이 없는데도 메모리 소모가 갑자기 높아진다면 코틀린을 최신버전로 업데이트할 것.


백그라운드에서 유닛테스트 할 때.
