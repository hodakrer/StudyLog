<리사이클러뷰의 모양새>:

  리사이클러뷰는 목록형 레이아웃이다.
  그리고 그 자체는 제법 심플하다.
  객체인 아이템뷰, 그리고 그걸 묶고 있는 뷰그룹인 라사이클러뷰다.
  그러나 내부는 제법 심오하다. 그 심오함을 느끼기 위해선 리사이클러뷰의 조상님인 '리스트뷰'를 알아야한다!


<리스트뷰란?>:

  옛날 옛적 스크롤화면이다.
  많은 아이템뷰가 리스트뷰로 몰려들 경우, 한번에 다 만들어야 해서 생성 속도가 떨어진다는 점이다.

  그러면 자연스레 최적화가 떠오르는 법.
  "아하! 현재 보여줄 아이템 뷰만 먼저 만듭시다!"

  그렇게 만들어진 것이 어뎁터이다.
  마치 그리스 신화의 아프로디테처럼, 현재의 올림포스 신들(리사이클러뷰)와는 출생이 동떨어진 양반이 바로 어뎁터였다.

  어뎁터는 아이템뷰를 재사용했다.
  스크롤하면 화면 바깥으로 사라지는 아이템뷰의 내용물을 바꿔 재등장시켰다.

  그럼에도 리스트뷰를 안쓰는 이유는 다음과 같다.

  1. 기능을 많이 추가하니 오작동이 난다.

  2. 기능을 많이 추가하니 다른 라이브러리의 기능과도 겹친다.

  3. 자주 쓰이는 기능이니 API 업데이트가 여러번이면 개발자도 곤란해진다.

  4. 빠르게 스크롤하면 중간중간 아이템뷰가 비는 에러가 났다. 즉, 애니메이션 처리가 어렵다는 것이다.

  5. 어뎁터는 업데이트 된 아이템의 위치(Position)을 알 수 없었다!


<리사이클러뷰의 구성요소>:

  눈치챘겠지만 위 문제들은 리사이클러뷰가 해결한 점이다.
  그럼 리스트뷰에서 어떻게 발전했는지 알아보자!

  1. LayoutManager: 아이템뷰를 바른 위치에 배치하는 컴포넌트다.

  2. ItemAnimator:  아이템뷰의 애니메이션을 처리한다.

  3. Adapter: 리사이클러뷰에 아이템뷰 정보를 제공한다.

  이렇게 새로운 것들이 생겨났다. 이들은 모두 컴포넌트이다.
  여기서 잠깐, 컴포넌트라면 항상 질문에 나오는 '안드로이드 4대 컴포넌트는 뭐죠?'가 떠오른다.

  그러나 여기서의 컴포넌트란 다르다!
  안드로이드의 4대 컴포넌트는 '앱의 핵심 동작을 정의하는 요소'이고,
  리사이클러뷰의 컴포넌트란 '리사이클러뷰의 UI를 표시, 관리하는 요소'란 뜻이다.
  그러므로 리사이클러의 아키텍처는 '컴포넌트 기반 아키텍처'이다.

  그렇다면 리사이클러뷰의 '심오함'을 익히기 전에 각 구성요소가 뭔지부터 제대로 파악하자.


<LayoutManager>

  LayoutManager는 크게 2가지를 책임진다.

  1. 아이템뷰를 배치하는 것(배치 순서)!

  2. 아이템뷰를 재활용하는 '시기' 결정!

  그러므로 리사이클러뷰나 어뎁터는 어떤 형태(리스트/그리드)로 배치되었는지 알 길이 없다.

  예를 들어 사용자가 스크롤을 내리면 리사이클러뷰와 LayoutManager는 소통을 한다.

  1. 리사이클러뷰 -> LayoutManager: '스크롤 내림'을 알린다.

  2. LayoutManager: 바인딩된 아이템과 데이터를 적절한 위치에 새로 배치한다.

  (공식문서를 보니 설명 아래로 수많은 함수들이 쏟아진다. 추후 공부해서 보강하겠다)


<Adapter>

  Adapter는 아이템뷰를 생성하는 컴포넌트다.
  리스트뷰에서의 문제는 어뎁터에게 많은 데이터를 던지고 '한번에 다 만들어'라고 해서 문제였다.
  그래서 우리의 리사이클러뷰는 '뷰홀더'라는 걸 만들어 어뎁터를 도왔다.

  어뎁터의 역할은 아래의 3가지다.

  1. 데이터셋이 업데이트되면 리사이클러뷰에게 그 사실을 알린다.

  2. 유저가 아이템을 클릭하면 상호작용(ex: onClickItemListener)를 책임진다.

  3. 아이템뷰가 다를 경우(데이터 말고 형태 말이다)에도 처리작업을 책임진다.


<ViewHolder>

  ViewHolder는 아이템뷰를 효율적으로 재활용하고, 성능을 최적화하는데 일조한다.
  
  그런데 이 뷰홀더의 동작과정이 좀 길다.

  단지 스크롤을 내리는 것만 해도 아래의 과정을 거친다.

  1. 리사이클러뷰 -> 레이아웃 매니저: 유저가 스크롤했음을 알린다.

  2. 레이아웃 매니저 -> 리사이클러뷰: 새 아이템뷰의 배치 위치(Pos)를 알려준다.

  3. 리사이클러뷰 <-> 아이템뷰 캐시: 다음에 나올 아이템뷰 정보를 요청하고 받는다.

  잠깐, 그런데 캐시면 그 안에 원하던 정보가 없을 수 있다!

  4 - 1. if 있다면, 리사이클러뷰 -> 레이아웃 매니저: 캐시에게서 얻은 아이템뷰 정보를 보낸다. 끝!

  4 - 2. else 없다면, 아이템뷰가 뭔지 모른다. 그리고 그 아이템뷰의 '뷰타입' 부터 모른다!

  5. 뷰타입도 모른다면 더 가관인 건 그 '뷰타입'을 위한 '뷰홀더'가 있냐부터 따져야한다.

  6 - 1. if 그래도 뷰홀더는 있지 -> 리사이클러뷰 -> 어뎁터: 뷰홀더와 아이템 위치(Pos)로 '바인딩'을 요청한다.
  그럼 뷰홀더 붙은 아이템을 받을 수 있다. 그럼 리사이클러뷰 -> 어뎁터 -> 리사이클러뷰 -> 레이아웃매니저(4- 1)순을 거쳐 화면에 세팅한다.

  6 - 2. else 뷰홀더도 없는데용 -> 리사이클러뷰 -> 어뎁터: 해당 '뷰타입' 위한 뷰홀더를 생성해달라 요청한다.
  그리고 어뎁터 -> 리사이클러뷰로 뷰홀더를 받는다. 그 후 6 - 1로 돌아간다.
  3에서의 아이템뷰 정보와 6 - 1에서의 뷰홀더를 어뎁터에 보내면 된다.
  그럼 4 - 1처럼 처리되고 끝난다.

  아, 복잡해라. 결국,
  1) 캐시에 아이템뷰 정보 있는가?
  2) 뷰홀더 정보는 있는가? 가 기준이다.


<onBindViewHolder( )>

  뷰홀더가 어떻게 작동하는지, 그 핵심 함수를 알아보자.

  파라미터: 4 - 1에서 온 뷰홀더 객체, 아이템뷰 정보(Pos, 위치)

  사용주체: 리사이클러뷰가 부름.

  구조: 리사이클러뷰 -(상황전달)-> tryBindViewHolderByDeadline() -(상황전달)-> adapter.bindViewHolder() -(데이터 업데이트 요청)-> onBindViewHolder()

  데이터 업데이트 대상: RecyclerView.ViewHolder.itemView의 데이터/컨텐츠들


<뷰홀더 재활용>

  이제 리사이클러뷰의 핵심 기능에 도달했다. 여기에 도달하기까지 정말 먼 길이었다!

  상황: 스크롤로 아이템뷰가 화면에서 사라짐.

  과정:

  1. 화면 밖으로 나간 아이템뷰가 있음을 리사이클러뷰가 인식한다.

  2. 리사이클러뷰 -> 케시(ViewCacheExtension): 이 아이템뷰에 대한 정보를 지워도 되냐고 물어본다.

  3 - 1. Yes: 캐시 -> RecyclerPool: 오래된 아이템뷰 정보(위치)를 전달한다.
  그 후, RecyclerPool은 뷰를 보관하고, 나중에 필요할 때 재사용한다.

  3 - 2. NO: 그럼 아이템뷰 정보를 캐시에 놔둡니다. 이 아이템뷰가 다시 요청받으면 어뎁터를 안 거치고 캐시 -> 리사이클러뷰 -> 레이아웃매니저로 제공됩니다.


<후기>

  조금 더 공부해봐야할 것 같다. 심지어 아이템뷰 캐시와 ViewCachExtension의 차이도 모르겠다. 뷰홀더 작동원리도 100% 이해하진 못했다. 추후 보강예정.
