[JVM]

JVM이란 자바가상기계란 뜻이다.
JVM은 같은 소스코드를 여러 환경에서 동일한 소스코드를 실행 보장한다.

예를 들어보자.
윈도우에서 파일입출력을 하는 함수는 리눅스의 함수와 다르다.
C와 같은 컴파일 언어라면 일일이 이런 상황을 예외처리해줘야한다.

하지만 JVM과 함께라면 다르다!
JVM은 컴퓨터 OS에 맞게 깔아줘야한다.
대신 KOTLIN은 컴퓨터 OS에 맞게 예외처리해주지 않아도 된다!

더 깊게 들어가서, 왜 이게 가능할까?


[코틀린 코드가 실행되는 순서]

소스코드는 컴파일러를 통해 .class인 바이트코드로 바뀐다.
c언어 소스코드가 어셈블리 코드 -> 기계어로 바뀌는 것과 다르다.

바이트코드는 JVM의 JIT(Just In Time)컴파일러를 통해 기계어로 바뀐다.
즉, 소스코드를 바이트코드로 컴파일해 JVM에 넘겨주면 OS의존성이 해결된다는 뜻이다.


[왜 자바 대신 코틀린인가?]

코틀린의 장점으로도 이어지는 질문이다.

첫째, 간결하게 표현할 수 있다.
구체적으로, 자주 반복되는 코드를 '보일러플레이트 코드'라고 한다.
금속활자틀이나 금속뱃지를 찍어내는 틀이 보일러플레이트다.
즉, 바뀌지도 않고 자주 쓰는 코드들을 말한다. '틀에 박힌 코드'란 뜻이다.

그럼 코틀린은 보일러플레이트 코드 문제를 어떻게 해결하나?

첫째, 코틀린 자체에서 보일러플레이트 코드를 생성해준다.
예를 들어 data class 객체는 알아서 toString을 만들어준다.
또한 val, var 프로퍼티는 알아서 게터/세터를 생성해준다.

둘째, 어노테이션 프로세서로 자동생성해준다.
이걸 도와주는 것이 KAPT이다! (이제 안드로이드에서 왜 쓰는지 알았다!)
특히 로컬 저장에 쓰는 ROOM 라이브러리에서 @ENTITY, @DAO를 쓰던게 기억난다.

[자바와 코틀린]

다시 코틀린의 장점으로 돌아와서, 코틀린의 장점은 무엇인가?
그건 JAVA와 혼용할 수 있다는 점이다.
이건 100% 혼용 가능하다.
그럼 왜 가능한가?

이유는 소스코드를 컴파일 시, 자바는 자바컴파일러가, 코틀린은 코틀린컴파일러가
바이트코드로 변환해주기 때문이다.
결국 JVM엔 똑같은 바이트코드가 들어오고 CPU는 JIT컴파일러에게서 똑같은 기계어 0101을 받는다.
이러한 이유로 자바의 풍부한 라이브러리도 갖다 쓸 수 있다.

그렇다면 또 '막 써도 되는가?' 라는 질문이 나올 수 있다.

둘을 같이 쓸 때 주의점 첫째, 클래스 파일 이름이나 패키지 구조 등 메타데이터는 고려해야한다.
예를 들어 코틀린은 파일 이름과 클래스 이름이 같지 않아도 된다. 그러나 자바는 같아야 한다.
(이건 내일 좀 더 알아봐야겠다)

그리고 주의점 둘째, 코틀린은 자바6부터 지원한다. 자바5에만 있는 내용을 코틀린 소스코드에 쓰면 문제가 생긴다.


[널포인터익셉션]

대망의 세번째 장점이다.
코틀린은 널안정성을 지원한다.
그럼 당연히 '어떻게' 지원하는가이다.

널포인터익셉션의 정의부터 알아보자.
프로그램이 null값을 참조하는 것이다.

그럼 null은 특정한 값인가? 타입인가?
둘 다 아니다. 그냥 '없음'을 나타내는 특수표현이다.

예를 들어, val str: String = null이면,
str은 null이란 특수값을 갖는게 아니다.
그냥 아예 없는 것이다.
컴퓨터적으로 표현하자면, 가리켜야할(참조할) 메모리 주소가 존재하지 않는 것이다.

예를 들어보자.
아까 str은 null이라고 했다.
그럼 str.length 프로퍼티는 뭐라고 나올까?
답은 널포인터익셉션이다.
str도 참조할 주소가 없으니 내부객체인 .length도 참조할 주소가 없는 것이다.


[왜 널포인터익셉션을 경계하나?]

일단 널포인터익셉션이 터지면 프로그램이 종료된다.
사용자는 당연히 기분이 나쁠 것이다.
프로그램적으론 '안전성'이 떨어진다.

무엇보다, 코드가 커지면 널포인터익셉션의 원인을 찾기 힘들다!
그러니 미리미리 예방하자는 것이다!
그럼 어떻게 예방하나?

[var과 val]
[?과 !!]
[lateinit과 by lazy]
